{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MoNvIso Documentation MoNvIso is a comprehensive software tool designed for the analysis and modeling of protein isoforms. It automates the process of identifying canonical and additional isoforms, assessing their modeling propensity, mapping mutations accurately, and building structural models of proteins. By leveraging data from the Uniprot database, MoNvIso facilitates a deeper understanding of protein function and variation. Overview The MoNvIso workflow is streamlined into three primary steps, making it both powerful and user-friendly for researchers and bioinformaticians alike. This workflow ensures a meticulous examination of gene names, isoforms, mutations, and the subsequent construction of structural models when experimental structures are not available. Step 1: Gene and Isoform Verification MoNvIso begins by verifying gene names provided in the user's input file, identifying both canonical and additional isoforms directly from the Uniprot database. The input file also includes a list of mutations of interest, setting the stage for detailed analysis in subsequent steps. Step 2: Modelling Propensity and Mutation Mapping This step focuses on assessing the suitability of available isoforms for modeling and how mutations map onto these isoforms. MoNvIso supervises the availability of templates and ensures mutations are associated with the appropriate isoforms. It identifies and highlights any discrepancies where mutations cannot be mapped, ensuring accuracy and reliability in the selection process. The selection procedure, known as the Selection Function, integrates two critical components: Structural Function: Assesses the modelling propensity. Mutation Function: Evaluates the mapping of mutations on the isoforms. Both functions are weighted (default: w1 = w2 = 10), which can be adjusted by the user to tailor the analysis. Step 3: Structural Model Building In the final step, MoNvIso builds structural models of the identified proteins, including both wild-type (WT) forms and their variants, selected based on the analysis conducted in Step 2. This step is only initiated if experimental structures are not already available, ensuring that only necessary modeling work is performed. Getting Started Dive into the world of protein isoform analysis with MoNvIso by exploring the following sections of our documentation: Installation Guide : Learn how to install MoNvIso on your system. Quick Start Tutorial : Get up and running with your first analysis. Understanding the Workflow: A deeper dive into each step of the MoNvIso workflow. FAQs : Answers to common questions about MoNvIso. MoNvIso is here to enhance your research with advanced protein isoform analysis and modeling. Whether you're investigating mutations, studying protein functions, or exploring structural variations, MoNvIso provides the tools you need to achieve your objectives with precision and ease.","title":"Home"},{"location":"#welcome-to-monviso-documentation","text":"MoNvIso is a comprehensive software tool designed for the analysis and modeling of protein isoforms. It automates the process of identifying canonical and additional isoforms, assessing their modeling propensity, mapping mutations accurately, and building structural models of proteins. By leveraging data from the Uniprot database, MoNvIso facilitates a deeper understanding of protein function and variation.","title":"Welcome to MoNvIso Documentation"},{"location":"#overview","text":"The MoNvIso workflow is streamlined into three primary steps, making it both powerful and user-friendly for researchers and bioinformaticians alike. This workflow ensures a meticulous examination of gene names, isoforms, mutations, and the subsequent construction of structural models when experimental structures are not available.","title":"Overview"},{"location":"#step-1-gene-and-isoform-verification","text":"MoNvIso begins by verifying gene names provided in the user's input file, identifying both canonical and additional isoforms directly from the Uniprot database. The input file also includes a list of mutations of interest, setting the stage for detailed analysis in subsequent steps.","title":"Step 1: Gene and Isoform Verification"},{"location":"#step-2-modelling-propensity-and-mutation-mapping","text":"This step focuses on assessing the suitability of available isoforms for modeling and how mutations map onto these isoforms. MoNvIso supervises the availability of templates and ensures mutations are associated with the appropriate isoforms. It identifies and highlights any discrepancies where mutations cannot be mapped, ensuring accuracy and reliability in the selection process. The selection procedure, known as the Selection Function, integrates two critical components: Structural Function: Assesses the modelling propensity. Mutation Function: Evaluates the mapping of mutations on the isoforms. Both functions are weighted (default: w1 = w2 = 10), which can be adjusted by the user to tailor the analysis.","title":"Step 2: Modelling Propensity and Mutation Mapping"},{"location":"#step-3-structural-model-building","text":"In the final step, MoNvIso builds structural models of the identified proteins, including both wild-type (WT) forms and their variants, selected based on the analysis conducted in Step 2. This step is only initiated if experimental structures are not already available, ensuring that only necessary modeling work is performed. Getting Started Dive into the world of protein isoform analysis with MoNvIso by exploring the following sections of our documentation: Installation Guide : Learn how to install MoNvIso on your system. Quick Start Tutorial : Get up and running with your first analysis. Understanding the Workflow: A deeper dive into each step of the MoNvIso workflow. FAQs : Answers to common questions about MoNvIso. MoNvIso is here to enhance your research with advanced protein isoform analysis and modeling. Whether you're investigating mutations, studying protein functions, or exploring structural variations, MoNvIso provides the tools you need to achieve your objectives with precision and ease.","title":"Step 3: Structural Model Building"},{"location":"FAQs/","text":"Frequently Asked Questions (FAQs) What settings are used for the BLAST search? blastp Database: swissprot Input: fasta_file.seq Alignments: 500 Word size: 6 What settings are used for COBALT to create the MSA (Multiple Sequence Alignment)? Output format: mfasta End gap open penalty: 5 End gap extend penalty: 1 Gap open penalty: 11 Gap extend penalty: 1 BLAST e-value: 0.003 No RPS: T Tree method: clust Can I use MoNvIso without an internet connection? No, MoNvIso requires an internet connection to access necessary databases like UniProt and PDB. What species' proteins can be modeled? Currently, MoNvIso only models proteins belonging to Homo sapiens as extracted from the UniProt database. How can I cite MoNvIso? Please cite MoNvIso as follows: Oliva, F., Musiani, F., Giorgetti, A., De Rubeis, S., Sorokina, O., Armstrong, D. J., Carloni, P., & Ruggerone, P. (2023). Modelling eNvironment for Isoforms (MoNvIso): A general platform to predict structural determinants of protein isoforms in genetic diseases. Frontiers in chemistry, 10, 1059593. https://doi.org/10.3389/fchem.2022.1059593","title":"FAQs"},{"location":"FAQs/#frequently-asked-questions-faqs","text":"","title":"Frequently Asked Questions (FAQs)"},{"location":"FAQs/#what-settings-are-used-for-the-blast-search","text":"blastp Database: swissprot Input: fasta_file.seq Alignments: 500 Word size: 6","title":"What settings are used for the BLAST search?"},{"location":"FAQs/#what-settings-are-used-for-cobalt-to-create-the-msa-multiple-sequence-alignment","text":"Output format: mfasta End gap open penalty: 5 End gap extend penalty: 1 Gap open penalty: 11 Gap extend penalty: 1 BLAST e-value: 0.003 No RPS: T Tree method: clust","title":"What settings are used for COBALT to create the MSA (Multiple Sequence Alignment)?"},{"location":"FAQs/#can-i-use-monviso-without-an-internet-connection","text":"No, MoNvIso requires an internet connection to access necessary databases like UniProt and PDB.","title":"Can I use MoNvIso without an internet connection?"},{"location":"FAQs/#what-species-proteins-can-be-modeled","text":"Currently, MoNvIso only models proteins belonging to Homo sapiens as extracted from the UniProt database.","title":"What species' proteins can be modeled?"},{"location":"FAQs/#how-can-i-cite-monviso","text":"Please cite MoNvIso as follows: Oliva, F., Musiani, F., Giorgetti, A., De Rubeis, S., Sorokina, O., Armstrong, D. J., Carloni, P., & Ruggerone, P. (2023). Modelling eNvironment for Isoforms (MoNvIso): A general platform to predict structural determinants of protein isoforms in genetic diseases. Frontiers in chemistry, 10, 1059593. https://doi.org/10.3389/fchem.2022.1059593","title":"How can I cite MoNvIso?"},{"location":"cobalt_wrapper/","text":"Cobalt Wrapper Class Overview The Cobalt class serves as a Python wrapper for COBALT (Constraint-based Multiple Alignment Tool), a software tool used for multiple sequence alignment (MSA). This class enables the integration of COBALT's alignment capabilities within Python applications, facilitating the automated processing of sequence alignments. Methods __init__(self) Initializes a new instance of the Cobalt class. This method prepares the environment for running COBALT alignments but does not require any parameters. run(self, hits_file: Union[str, Path], aligned_file: Union[str, Path], cobalt_home: str) -> bool Executes the COBALT alignment process on a specified set of sequences. Parameters: hits_file : The path to the input file containing sequence data to be aligned, typically the output from a BLASTP search. This can be a str or Path object. aligned_file : The path to the output file where the aligned sequences will be saved, in multi-FASTA format. This can be a str or Path object. cobalt_home : The file system path to the COBALT installation directory, which contains the COBALT executable. Returns: bool : Returns True if the COBALT alignment completes successfully, otherwise returns False .","title":"Cobalt wrapper"},{"location":"cobalt_wrapper/#cobalt-wrapper-class","text":"","title":"Cobalt Wrapper Class"},{"location":"cobalt_wrapper/#overview","text":"The Cobalt class serves as a Python wrapper for COBALT (Constraint-based Multiple Alignment Tool), a software tool used for multiple sequence alignment (MSA). This class enables the integration of COBALT's alignment capabilities within Python applications, facilitating the automated processing of sequence alignments.","title":"Overview"},{"location":"cobalt_wrapper/#methods","text":"","title":"Methods"},{"location":"cobalt_wrapper/#__init__self","text":"Initializes a new instance of the Cobalt class. This method prepares the environment for running COBALT alignments but does not require any parameters.","title":"__init__(self)"},{"location":"cobalt_wrapper/#runself-hits_file-unionstr-path-aligned_file-unionstr-path-cobalt_home-str-bool","text":"Executes the COBALT alignment process on a specified set of sequences. Parameters: hits_file : The path to the input file containing sequence data to be aligned, typically the output from a BLASTP search. This can be a str or Path object. aligned_file : The path to the output file where the aligned sequences will be saved, in multi-FASTA format. This can be a str or Path object. cobalt_home : The file system path to the COBALT installation directory, which contains the COBALT executable. Returns: bool : Returns True if the COBALT alignment completes successfully, otherwise returns False .","title":"run(self, hits_file: Union[str, Path], aligned_file: Union[str, Path], cobalt_home: str) -&gt; bool"},{"location":"database_parser/","text":"Database Parser Class Overview The DatabaseParser class is designed for processing Uniprot databases to retrieve sequences for specific genes. It facilitates the parsing of canonical and noncanonical (split variants) isoform databases downloaded from Uniprot. Methods __init__(self, db_location: str) Initializes the DatabaseParser with the location of the Uniprot databases. It automatically loads the databases upon initialization. Parameters: db_location : A string specifying the filesystem path to the directory containing the Uniprot database files. parse_database(database_path: Path) -> list[list[str]] Parses a given database file, organizing its content into a structured list format where each element represents a single sequence. Parameters: database_path : A Path object pointing to the Uniprot database file to be parsed. Returns: A list of gene sequences, each represented as a list of strings corresponding to lines from the database. load_database() Loads the canonical and noncanonical isoform databases from Uniprot, making them available as local attributes for query operations. get_canonical_isoforms(gene_name: str) -> list[list[str]] Retrieves sequences corresponding to the specified gene from the canonical database. Parameters: gene_name : The name of the gene for which sequences are being retrieved. Returns: A list of sequences for the specified gene, with each sequence split across multiple lines. get_noncanonical_isoforms(gene_name: str) -> list[list[str]] Retrieves sequences corresponding to the specified gene from the noncanonical (split variants) database. Parameters: gene_name : The name of the gene for which sequences are being retrieved. Returns: A list of sequences for the specified gene, with each sequence split across multiple lines.","title":"Database Parser"},{"location":"database_parser/#database-parser-class","text":"","title":"Database Parser Class"},{"location":"database_parser/#overview","text":"The DatabaseParser class is designed for processing Uniprot databases to retrieve sequences for specific genes. It facilitates the parsing of canonical and noncanonical (split variants) isoform databases downloaded from Uniprot.","title":"Overview"},{"location":"database_parser/#methods","text":"","title":"Methods"},{"location":"database_parser/#__init__self-db_location-str","text":"Initializes the DatabaseParser with the location of the Uniprot databases. It automatically loads the databases upon initialization. Parameters: db_location : A string specifying the filesystem path to the directory containing the Uniprot database files.","title":"__init__(self, db_location: str)"},{"location":"database_parser/#parse_databasedatabase_path-path-listliststr","text":"Parses a given database file, organizing its content into a structured list format where each element represents a single sequence. Parameters: database_path : A Path object pointing to the Uniprot database file to be parsed. Returns: A list of gene sequences, each represented as a list of strings corresponding to lines from the database.","title":"parse_database(database_path: Path) -&gt; list[list[str]]"},{"location":"database_parser/#load_database","text":"Loads the canonical and noncanonical isoform databases from Uniprot, making them available as local attributes for query operations.","title":"load_database()"},{"location":"database_parser/#get_canonical_isoformsgene_name-str-listliststr","text":"Retrieves sequences corresponding to the specified gene from the canonical database. Parameters: gene_name : The name of the gene for which sequences are being retrieved. Returns: A list of sequences for the specified gene, with each sequence split across multiple lines.","title":"get_canonical_isoforms(gene_name: str) -&gt; list[list[str]]"},{"location":"database_parser/#get_noncanonical_isoformsgene_name-str-listliststr","text":"Retrieves sequences corresponding to the specified gene from the noncanonical (split variants) database. Parameters: gene_name : The name of the gene for which sequences are being retrieved. Returns: A list of sequences for the specified gene, with each sequence split across multiple lines.","title":"get_noncanonical_isoforms(gene_name: str) -&gt; list[list[str]]"},{"location":"file_handler/","text":"FileHandler Class Overview The FileHandler class provides a simple interface for file and directory operations, including creation, deletion, reading, writing, and moving files. It's designed to unify the complexity of file handling in all the classes of the module, making it easier to fix bugs. Methods remove_file(self, file_path: Union[str, Path]) Removes a file at the specified path. Parameters: file_path : The path to the file to be removed. create_directory(self, dir_path: Union[str, Path]) Creates a new directory at the specified path. If necessary, it will create all intermediate directories. Parameters: dir_path : The path where the new directory will be created. move_file(self, src: Union[str, Path], dest: Union[str, Path]) Moves a file from the source path to the destination path. Parameters: src : The source file path. dest : The destination path. copy_file(self, src: Union[str, Path], dest: Union[str, Path]) Copies a file from the source path to the destination path. Parameters: src : The source file path. dest : The destination path. write_file(self, file_path: Union[str, Path], content: str) Writes content to a file at the specified path. If the file exists, it will be removed before writing the new content. Parameters: file_path : The file path where the content will be written. content : The content to write to the file. check_existence(self, path: Union[str, Path]) -> bool Checks whether a file or directory exists at the specified path. Parameters: path : The path of the file or directory to check. Returns: bool : True if the file or directory exists, False otherwise. read_file(self, path: Union[str, Path]) -> str Reads and returns the content of a file at the specified path. Parameters: path : The path of the file to read. Returns: str : The content of the file.","title":"File handler"},{"location":"file_handler/#filehandler-class","text":"","title":"FileHandler Class"},{"location":"file_handler/#overview","text":"The FileHandler class provides a simple interface for file and directory operations, including creation, deletion, reading, writing, and moving files. It's designed to unify the complexity of file handling in all the classes of the module, making it easier to fix bugs.","title":"Overview"},{"location":"file_handler/#methods","text":"","title":"Methods"},{"location":"file_handler/#remove_fileself-file_path-unionstr-path","text":"Removes a file at the specified path. Parameters: file_path : The path to the file to be removed.","title":"remove_file(self, file_path: Union[str, Path])"},{"location":"file_handler/#create_directoryself-dir_path-unionstr-path","text":"Creates a new directory at the specified path. If necessary, it will create all intermediate directories. Parameters: dir_path : The path where the new directory will be created.","title":"create_directory(self, dir_path: Union[str, Path])"},{"location":"file_handler/#move_fileself-src-unionstr-path-dest-unionstr-path","text":"Moves a file from the source path to the destination path. Parameters: src : The source file path. dest : The destination path.","title":"move_file(self, src: Union[str, Path], dest: Union[str, Path])"},{"location":"file_handler/#copy_fileself-src-unionstr-path-dest-unionstr-path","text":"Copies a file from the source path to the destination path. Parameters: src : The source file path. dest : The destination path.","title":"copy_file(self, src: Union[str, Path], dest: Union[str, Path])"},{"location":"file_handler/#write_fileself-file_path-unionstr-path-content-str","text":"Writes content to a file at the specified path. If the file exists, it will be removed before writing the new content. Parameters: file_path : The file path where the content will be written. content : The content to write to the file.","title":"write_file(self, file_path: Union[str, Path], content: str)"},{"location":"file_handler/#check_existenceself-path-unionstr-path-bool","text":"Checks whether a file or directory exists at the specified path. Parameters: path : The path of the file or directory to check. Returns: bool : True if the file or directory exists, False otherwise.","title":"check_existence(self, path: Union[str, Path]) -&gt; bool"},{"location":"file_handler/#read_fileself-path-unionstr-path-str","text":"Reads and returns the content of a file at the specified path. Parameters: path : The path of the file to read. Returns: str : The content of the file.","title":"read_file(self, path: Union[str, Path]) -&gt; str"},{"location":"gene/","text":"Gene Class Overview The Gene class is a core component of the Monviso bioinformatics tool, designed to manage gene-specific operations. This class is responsible for managing the analysis of a single gene within the broader context of Monviso's genetic analysis capabilities. It performs tasks such as creating directories for gene-specific data, managing isoform objects that handle detailed calculations, and generating reports on the analysis. Attributes name : The name of the gene being analyzed. mutations : A list of mutations associated with the gene, standardized for analysis. mappable_mutations : A list of mutations that can be mapped onto at least one isoform of the gene. out_path : The output path where the gene-specific directory is created. sequences : The list of canonical and noncanonical sequences associated with the gene. isoforms : A collection of Isoform objects representing the different isoforms of the gene. isoforms_to_model : A list of isoforms selected for modeling based on certain criteria. Methods __init__(self, gene_mutation_block: list[list], out_path: str) Initializes a new instance of the Gene class. Parameters: gene_mutation_block : A list containing the gene name and associated mutations. out_path : The base directory where gene-specific directories will be created. create_directory(self) -> None Creates an empty directory for the gene in the specified output path. load_sequences(self, db_parser: DatabaseParser) -> None Loads canonical and noncanonical sequences for the gene from the Uniprot databases. Parameters: db_parser : An instance of DatabaseParser used to fetch gene sequences. load_isoforms(self, db_parser: DatabaseParser) -> None Creates an Isoform object for each sequence if at least one mutation can be mapped onto it. Parameters: db_parser : An instance of DatabaseParser . select_isoforms(self, w1: float, w2: float, sequence_identity_cutoff: float, model_cutoff: int) -> None Selects isoforms for modeling based on scores, sequence identity, and other criteria. Parameters: w1 : Weight of the structural function. w2 : Weight of the mutation function. sequence_identity_cutoff : Sequence identity threshold for template filtering. model_cutoff : Cutoff value for model selection. write_report(self) Generates and writes a report summarizing the analysis for the gene, including information about requested mutations, mappable mutations, isoform scores, and models. Private Methods These methods are used internally by the Gene class and are not intended for direct external usage. _check_presence_mutated_residue(self, sequence: str, mutation: list) -> bool Checks if a specific residue mutation can be applied to the sequence. _standardize_mutations(self, mutation_list) -> list Standardizes mutation representations by removing whitespace and converting residue names to a one-letter format. _report_on_selected_isoforms(self) Generates a console report on the isoforms selected for modeling.","title":"Gene"},{"location":"gene/#gene-class","text":"","title":"Gene Class"},{"location":"gene/#overview","text":"The Gene class is a core component of the Monviso bioinformatics tool, designed to manage gene-specific operations. This class is responsible for managing the analysis of a single gene within the broader context of Monviso's genetic analysis capabilities. It performs tasks such as creating directories for gene-specific data, managing isoform objects that handle detailed calculations, and generating reports on the analysis.","title":"Overview"},{"location":"gene/#attributes","text":"name : The name of the gene being analyzed. mutations : A list of mutations associated with the gene, standardized for analysis. mappable_mutations : A list of mutations that can be mapped onto at least one isoform of the gene. out_path : The output path where the gene-specific directory is created. sequences : The list of canonical and noncanonical sequences associated with the gene. isoforms : A collection of Isoform objects representing the different isoforms of the gene. isoforms_to_model : A list of isoforms selected for modeling based on certain criteria.","title":"Attributes"},{"location":"gene/#methods","text":"","title":"Methods"},{"location":"gene/#__init__self-gene_mutation_block-listlist-out_path-str","text":"Initializes a new instance of the Gene class.","title":"__init__(self, gene_mutation_block: list[list], out_path: str)"},{"location":"gene/#parameters","text":"gene_mutation_block : A list containing the gene name and associated mutations. out_path : The base directory where gene-specific directories will be created.","title":"Parameters:"},{"location":"gene/#create_directoryself-none","text":"Creates an empty directory for the gene in the specified output path.","title":"create_directory(self) -&gt; None"},{"location":"gene/#load_sequencesself-db_parser-databaseparser-none","text":"Loads canonical and noncanonical sequences for the gene from the Uniprot databases.","title":"load_sequences(self, db_parser: DatabaseParser) -&gt; None"},{"location":"gene/#parameters_1","text":"db_parser : An instance of DatabaseParser used to fetch gene sequences.","title":"Parameters:"},{"location":"gene/#load_isoformsself-db_parser-databaseparser-none","text":"Creates an Isoform object for each sequence if at least one mutation can be mapped onto it.","title":"load_isoforms(self, db_parser: DatabaseParser) -&gt; None"},{"location":"gene/#parameters_2","text":"db_parser : An instance of DatabaseParser .","title":"Parameters:"},{"location":"gene/#select_isoformsself-w1-float-w2-float-sequence_identity_cutoff-float-model_cutoff-int-none","text":"Selects isoforms for modeling based on scores, sequence identity, and other criteria.","title":"select_isoforms(self, w1: float, w2: float, sequence_identity_cutoff: float, model_cutoff: int) -&gt; None"},{"location":"gene/#parameters_3","text":"w1 : Weight of the structural function. w2 : Weight of the mutation function. sequence_identity_cutoff : Sequence identity threshold for template filtering. model_cutoff : Cutoff value for model selection.","title":"Parameters:"},{"location":"gene/#write_reportself","text":"Generates and writes a report summarizing the analysis for the gene, including information about requested mutations, mappable mutations, isoform scores, and models.","title":"write_report(self)"},{"location":"gene/#private-methods","text":"These methods are used internally by the Gene class and are not intended for direct external usage.","title":"Private Methods"},{"location":"gene/#_check_presence_mutated_residueself-sequence-str-mutation-list-bool","text":"Checks if a specific residue mutation can be applied to the sequence.","title":"_check_presence_mutated_residue(self, sequence: str, mutation: list) -&gt; bool"},{"location":"gene/#_standardize_mutationsself-mutation_list-list","text":"Standardizes mutation representations by removing whitespace and converting residue names to a one-letter format.","title":"_standardize_mutations(self, mutation_list) -&gt; list"},{"location":"gene/#_report_on_selected_isoformsself","text":"Generates a console report on the isoforms selected for modeling.","title":"_report_on_selected_isoforms(self)"},{"location":"input_parser/","text":"InputParser Class The InputParser class extends argparse.ArgumentParser to provide a flexible and user-friendly interface for handling command line arguments as well as parameters from a file. It is specifically tailored for applications that require a dynamic configuration of execution parameters, supporting both direct command line input and the use of a parameters file (loaded with the -p flag). Overview This class allows for specifying computational parameters and execution environment settings through the command line or by providing a path to a structured parameters file. It is used internally by the Run class to do so. It supports validation and merging of parameters to ensure that the execution environment is correctly set up according to the user's specifications. Expected Parameters The InputParser class processes and validates a variety of input parameters essential for the execution of our computational workflow. Here's an overview of these parameters and their significance: Resolution : The minimum template resolution (in \u00c5) for the modeling process, specified as RESOLUTION . Only valid for Cryo-EM and X-Ray structures. All NMR structures are accepted. SEQ ID : The minimum sequence identity threshold, expressed as a percentage ( SEQID ), for selecting templates. Templates with a sequence identity lower than this threshold will be discarded. WT Models to Prepare : The number of wild-type models to be prepared, indicated by NUM_OF_MOD_WT . Mutants Model to Prepare : Specifies the number of mutant models to prepare, NUM_OF_MOD_MUT . Max PDBs as Templates : The maximum number of PDB templates to use in modeling, PDB_TO_USE . This helps in narrowing down the best templates for accurate modeling. Residues Cutoff : A cutoff for residues, MODEL_CUTOFF , where non-covered regions in the alignment that are this length or longer will be replaced by chain breaks. Input File : Path to the input file containing mutation information, accessed via args.input_file . Output Directory : The directory where output files will be stored, args.out_path . Databases Directory : Location of the databases downloaded from Uniprot, including isoforms, specified in DB_LOCATION . COBALT : Path to the COBALT executable, COBALT_HOME , used for sequence alignment. HMMER : Location of the HMMER software executable, HMMER_HOME , essential for sequence analysis. Weight Structural Score : The weight assigned to the structural score in the modeling process, W_STRUCT . For details on how weights are utilized, refer to Oliva et al. . Weight Mutation Score : Specifies the weight for the mutation score, W_MUT , as described in the referenced publication by Oliva et al. Modeller Executable : Path to the MODELLER executable, MODELLER_EXEC , for homology or comparative modeling of protein three-dimensional structures. Class Methods __init__(self, *args, **kwargs) Initializes the parser with any arguments and keyword arguments acceptable by argparse.ArgumentParser , and sets up the expected arguments. add_arguments(self) -> None Defines and adds expected command line arguments to the parser. These include paths to input and output files, paths to external tools like COBALT and HMMER, and computational parameters such as resolution and sequence identity. check_arguments(self, args: argparse.Namespace) -> None Checks the provided command line arguments to ensure that all necessary information is available. Raises an error if required arguments are missing or if there's a conflict between the parameters file and manual input. parse_input(self, mutation_file_path: str) -> List Parses a given file containing a list of mutations and genes. Returns a structured list containing this information for further processing. get_parameters(self, parameters_path: str = \"parameters.dat\") -> Dict Loads and returns parameters from a specified parameters file. Defaults to 'parameters.dat' if no file path is provided. This method structures the parameters into a dictionary for easy access. merge_parameters(self, args: argparse.Namespace) -> Dict Merges parameters provided through the command line with those loaded from the parameters file. This ensures that command line arguments take precedence over file-based parameters. print_parameters(self, args: argparse.Namespace, parameters: Dict) -> None Prints the final set of parameters that will be used for execution. This includes both command line arguments and parameters loaded from the file, highlighting the configuration for the user. load_input(self, argv) -> tuple The main method for loading and validating user inputs. It parses command line arguments, validates them, loads additional parameters from a file if specified, and merges them as necessary. Returns a tuple containing the structured arguments and parameters.","title":"Input Parser"},{"location":"input_parser/#inputparser-class","text":"The InputParser class extends argparse.ArgumentParser to provide a flexible and user-friendly interface for handling command line arguments as well as parameters from a file. It is specifically tailored for applications that require a dynamic configuration of execution parameters, supporting both direct command line input and the use of a parameters file (loaded with the -p flag).","title":"InputParser Class"},{"location":"input_parser/#overview","text":"This class allows for specifying computational parameters and execution environment settings through the command line or by providing a path to a structured parameters file. It is used internally by the Run class to do so. It supports validation and merging of parameters to ensure that the execution environment is correctly set up according to the user's specifications.","title":"Overview"},{"location":"input_parser/#expected-parameters","text":"The InputParser class processes and validates a variety of input parameters essential for the execution of our computational workflow. Here's an overview of these parameters and their significance: Resolution : The minimum template resolution (in \u00c5) for the modeling process, specified as RESOLUTION . Only valid for Cryo-EM and X-Ray structures. All NMR structures are accepted. SEQ ID : The minimum sequence identity threshold, expressed as a percentage ( SEQID ), for selecting templates. Templates with a sequence identity lower than this threshold will be discarded. WT Models to Prepare : The number of wild-type models to be prepared, indicated by NUM_OF_MOD_WT . Mutants Model to Prepare : Specifies the number of mutant models to prepare, NUM_OF_MOD_MUT . Max PDBs as Templates : The maximum number of PDB templates to use in modeling, PDB_TO_USE . This helps in narrowing down the best templates for accurate modeling. Residues Cutoff : A cutoff for residues, MODEL_CUTOFF , where non-covered regions in the alignment that are this length or longer will be replaced by chain breaks. Input File : Path to the input file containing mutation information, accessed via args.input_file . Output Directory : The directory where output files will be stored, args.out_path . Databases Directory : Location of the databases downloaded from Uniprot, including isoforms, specified in DB_LOCATION . COBALT : Path to the COBALT executable, COBALT_HOME , used for sequence alignment. HMMER : Location of the HMMER software executable, HMMER_HOME , essential for sequence analysis. Weight Structural Score : The weight assigned to the structural score in the modeling process, W_STRUCT . For details on how weights are utilized, refer to Oliva et al. . Weight Mutation Score : Specifies the weight for the mutation score, W_MUT , as described in the referenced publication by Oliva et al. Modeller Executable : Path to the MODELLER executable, MODELLER_EXEC , for homology or comparative modeling of protein three-dimensional structures.","title":"Expected Parameters"},{"location":"input_parser/#class-methods","text":"","title":"Class Methods"},{"location":"input_parser/#__init__self-args-kwargs","text":"Initializes the parser with any arguments and keyword arguments acceptable by argparse.ArgumentParser , and sets up the expected arguments.","title":"__init__(self, *args, **kwargs)"},{"location":"input_parser/#add_argumentsself-none","text":"Defines and adds expected command line arguments to the parser. These include paths to input and output files, paths to external tools like COBALT and HMMER, and computational parameters such as resolution and sequence identity.","title":"add_arguments(self) -&gt; None"},{"location":"input_parser/#check_argumentsself-args-argparsenamespace-none","text":"Checks the provided command line arguments to ensure that all necessary information is available. Raises an error if required arguments are missing or if there's a conflict between the parameters file and manual input.","title":"check_arguments(self, args: argparse.Namespace) -&gt; None"},{"location":"input_parser/#parse_inputself-mutation_file_path-str-list","text":"Parses a given file containing a list of mutations and genes. Returns a structured list containing this information for further processing.","title":"parse_input(self, mutation_file_path: str) -&gt; List"},{"location":"input_parser/#get_parametersself-parameters_path-str-parametersdat-dict","text":"Loads and returns parameters from a specified parameters file. Defaults to 'parameters.dat' if no file path is provided. This method structures the parameters into a dictionary for easy access.","title":"get_parameters(self, parameters_path: str = \"parameters.dat\") -&gt; Dict"},{"location":"input_parser/#merge_parametersself-args-argparsenamespace-dict","text":"Merges parameters provided through the command line with those loaded from the parameters file. This ensures that command line arguments take precedence over file-based parameters.","title":"merge_parameters(self, args: argparse.Namespace) -&gt; Dict"},{"location":"input_parser/#print_parametersself-args-argparsenamespace-parameters-dict-none","text":"Prints the final set of parameters that will be used for execution. This includes both command line arguments and parameters loaded from the file, highlighting the configuration for the user.","title":"print_parameters(self, args: argparse.Namespace, parameters: Dict) -&gt; None"},{"location":"input_parser/#load_inputself-argv-tuple","text":"The main method for loading and validating user inputs. It parses command line arguments, validates them, loads additional parameters from a file if specified, and merges them as necessary. Returns a tuple containing the structured arguments and parameters.","title":"load_input(self, argv) -&gt; tuple"},{"location":"installation/","text":"Installation Guide This guide will help you set up the environment and install the necessary tools for using the MonViso Reloaded package. Requirements Before proceeding with the installation, ensure you have the following prerequisites: Python 3.9: The core language used for the project. Cobalt: A multiple sequence alignment tool. Download from NCBI Cobalt . HMMER: Software for searching sequence databases for sequence homologs. Available at HMMER . Modeller: Used for homology or comparative modeling of protein three-dimensional structures. Download from Modeller . Installation Steps Follow these steps to install the necessary tools and the MonViso Reloaded package: 1. Install Dependencies HMMER: Follow the installation instructions provided on the HMMER website. COBALT: Refer to the Cobalt download page for detailed installation instructions. MODELLER: Visit the Modeller website for installation guides tailored to your operating system. 2. Check Python Version Ensure you have Python 3.9 installed by running the following command in your terminal: python --version 3. Install via pip pip install monviso Verifying the installation After completing the installation steps, verify that the MonViso Reloaded package and all dependencies are correctly installed by running a quick test command or script provided by the package documentation. Alternative - Clone the GitHub Repository Clone the MonViso Reloaded repository to your local machine: git clone https://github.com/alisamalb/monviso_reloaded cd monviso_reloaded Install the package by executing: python setup.py install Alternative - Run the Docker container Save the Containerfile from https://raw.githubusercontent Installation Instructions To get started with installing Monviso, please follow the steps below: Download the Containerfile: First, you need to download the Containerfile. Save the file from this URL: Containerfile . Insert Your Modeller License: Open the downloaded Containerfile in a text editor and replace XXXX with your Modeller license key. This step is crucial for ensuring that Modeller functions correctly within the container. Build the Docker Image: With the license key in place, you can now build your Docker image. Open a terminal and run the following command in the directory where the Containerfile is located: docker build -t monviso -f Containerfile . This command builds a Docker image named monviso using the instructions in your Containerfile. Run the Container with a Mounted Working Directory: If you wish to use your own working directory (e.g., /Work) inside the container, you can do so by mounting it when you start the container. Run the following command to start the container and access your working directory within it: docker run -it -v /Work:/Monviso/Work monviso Replace /Work with the path to your actual working directory on the host machine. This command mounts your host directory /Work to /Monviso/Work inside the container, allowing you to work with your files directly from within the container environment. By following these steps, you'll have a fully functional Monviso environment set up and ready to use in Docker, complete with your required Modeller license and access to your working directory.","title":"Installation"},{"location":"installation/#installation-guide","text":"This guide will help you set up the environment and install the necessary tools for using the MonViso Reloaded package.","title":"Installation Guide"},{"location":"installation/#requirements","text":"Before proceeding with the installation, ensure you have the following prerequisites: Python 3.9: The core language used for the project. Cobalt: A multiple sequence alignment tool. Download from NCBI Cobalt . HMMER: Software for searching sequence databases for sequence homologs. Available at HMMER . Modeller: Used for homology or comparative modeling of protein three-dimensional structures. Download from Modeller .","title":"Requirements"},{"location":"installation/#installation-steps","text":"Follow these steps to install the necessary tools and the MonViso Reloaded package:","title":"Installation Steps"},{"location":"installation/#1-install-dependencies","text":"HMMER: Follow the installation instructions provided on the HMMER website. COBALT: Refer to the Cobalt download page for detailed installation instructions. MODELLER: Visit the Modeller website for installation guides tailored to your operating system.","title":"1. Install Dependencies"},{"location":"installation/#2-check-python-version","text":"Ensure you have Python 3.9 installed by running the following command in your terminal: python --version","title":"2. Check Python Version"},{"location":"installation/#3-install-via-pip","text":"pip install monviso","title":"3. Install via pip"},{"location":"installation/#verifying-the-installation","text":"After completing the installation steps, verify that the MonViso Reloaded package and all dependencies are correctly installed by running a quick test command or script provided by the package documentation.","title":"Verifying the installation"},{"location":"installation/#alternative-clone-the-github-repository","text":"Clone the MonViso Reloaded repository to your local machine: git clone https://github.com/alisamalb/monviso_reloaded cd monviso_reloaded Install the package by executing: python setup.py install","title":"Alternative - Clone the GitHub Repository"},{"location":"installation/#alternative-run-the-docker-container","text":"Save the Containerfile from https://raw.githubusercontent","title":"Alternative - Run the Docker container"},{"location":"installation/#installation-instructions","text":"To get started with installing Monviso, please follow the steps below: Download the Containerfile: First, you need to download the Containerfile. Save the file from this URL: Containerfile . Insert Your Modeller License: Open the downloaded Containerfile in a text editor and replace XXXX with your Modeller license key. This step is crucial for ensuring that Modeller functions correctly within the container. Build the Docker Image: With the license key in place, you can now build your Docker image. Open a terminal and run the following command in the directory where the Containerfile is located: docker build -t monviso -f Containerfile . This command builds a Docker image named monviso using the instructions in your Containerfile. Run the Container with a Mounted Working Directory: If you wish to use your own working directory (e.g., /Work) inside the container, you can do so by mounting it when you start the container. Run the following command to start the container and access your working directory within it: docker run -it -v /Work:/Monviso/Work monviso Replace /Work with the path to your actual working directory on the host machine. This command mounts your host directory /Work to /Monviso/Work inside the container, allowing you to work with your files directly from within the container environment. By following these steps, you'll have a fully functional Monviso environment set up and ready to use in Docker, complete with your required Modeller license and access to your working directory.","title":"Installation Instructions"},{"location":"isoform/","text":"Isoform Class Documentation Overview The Isoform class is a central component of the Monviso package, encapsulating comprehensive information about gene isoforms, including their sequences, mutations, and alignments. It is designed to facilitate sophisticated calculations and analyses on these sequences, making it an invaluable tool for computational biology researchers and developers. This class supports mutation assessment, sequence alignment, and the generation of structural models, among other functionalities. Attributes Upon initialization, the Isoform class sets up several attributes that are crucial for its operation: gene_name : The name of the gene associated with this isoform. isoform_index : An integer representing the isoform's index or identifier. isoform_name : A string derived from the isoform index, prefixed with \"isoform\" for easy identification. mutations : A list of mutations associated with this isoform. first_line : The first line of the sequence, often containing a descriptor or header. sequence : The actual sequence of the isoform, typically represented as a list of strings. out_path : The output directory path where the isoform's data (sequences, templates, models) will be stored. mutation_score : Initialized to 0, intended to hold a score based on mutation analysis. structural_score : Initialized to 0, intended to represent a score derived from structural analysis. selection_score : Initialized to 0, a composite score that may incorporate various scoring metrics. templates : An initially empty list, intended to hold template data used in modeling. modellable : A boolean flag indicating whether the isoform can be modeled based on available templates. aligned_sequence : A string to store the sequence aligned against a reference or template. clean_aligned_sequence : A version of aligned_sequence with gaps in place of long non-covered regions. modeller_run : Initially None , intended to hold workflow manager related to running the Modeller software for structural modeling. Methods create_directory(self) : Creates a directory specific to the isoform within the gene's directory structure. save_fasta_sequence(self) : Saves the isoform's sequence in FASTA format to the specified output path. blastp_search(self) : Initiates a BLASTP search with the isoform sequence as the query, storing results locally. create_MSA(self, cobalt_home) : Generates a multiple sequence alignment (MSA) from BLASTP search results. buildHMM(self, hmmer_home) : Constructs an HMM file from the MSA for template searching. HMMsearch(self, hmmer_home) : Conducts a search for structural templates using the generated HMM file. _extract_pdb_names(self, max_pdb) : Extracts PDB names from the HMM search results, limited by max_pdb . _template_alignment(self, cobalt_home) : Creates an alignment of template sequences, incorporating the isoform sequence. load_templates() : Initializes template objects based on PDB names and chain identifiers. _add_chain_breaks(self, sequences, model_cutoff) : Inserts chain breaks in alignments to facilitate sequence identity calculation. calculate_mutation_score(self, mappable_mutations) : Calculates a score based on the ratio of mappable mutations. calculate_structural_score(self, model_cutoff) : Assesses coverage of the isoform sequence by template structures. filter_templates_by_sequence_identity() : Filters out templates with sequence identity below a specified threshold. calculate_selection_score() : Computes a selection score based on structural and mutation scores. run_modeller(self, mutation, modeller_exec, model_cutoff) : Manages the execution of Modeller for structural modeling.","title":"Isoform"},{"location":"isoform/#isoform-class-documentation","text":"","title":"Isoform Class Documentation"},{"location":"isoform/#overview","text":"The Isoform class is a central component of the Monviso package, encapsulating comprehensive information about gene isoforms, including their sequences, mutations, and alignments. It is designed to facilitate sophisticated calculations and analyses on these sequences, making it an invaluable tool for computational biology researchers and developers. This class supports mutation assessment, sequence alignment, and the generation of structural models, among other functionalities.","title":"Overview"},{"location":"isoform/#attributes","text":"Upon initialization, the Isoform class sets up several attributes that are crucial for its operation: gene_name : The name of the gene associated with this isoform. isoform_index : An integer representing the isoform's index or identifier. isoform_name : A string derived from the isoform index, prefixed with \"isoform\" for easy identification. mutations : A list of mutations associated with this isoform. first_line : The first line of the sequence, often containing a descriptor or header. sequence : The actual sequence of the isoform, typically represented as a list of strings. out_path : The output directory path where the isoform's data (sequences, templates, models) will be stored. mutation_score : Initialized to 0, intended to hold a score based on mutation analysis. structural_score : Initialized to 0, intended to represent a score derived from structural analysis. selection_score : Initialized to 0, a composite score that may incorporate various scoring metrics. templates : An initially empty list, intended to hold template data used in modeling. modellable : A boolean flag indicating whether the isoform can be modeled based on available templates. aligned_sequence : A string to store the sequence aligned against a reference or template. clean_aligned_sequence : A version of aligned_sequence with gaps in place of long non-covered regions. modeller_run : Initially None , intended to hold workflow manager related to running the Modeller software for structural modeling.","title":"Attributes"},{"location":"isoform/#methods","text":"create_directory(self) : Creates a directory specific to the isoform within the gene's directory structure. save_fasta_sequence(self) : Saves the isoform's sequence in FASTA format to the specified output path. blastp_search(self) : Initiates a BLASTP search with the isoform sequence as the query, storing results locally. create_MSA(self, cobalt_home) : Generates a multiple sequence alignment (MSA) from BLASTP search results. buildHMM(self, hmmer_home) : Constructs an HMM file from the MSA for template searching. HMMsearch(self, hmmer_home) : Conducts a search for structural templates using the generated HMM file. _extract_pdb_names(self, max_pdb) : Extracts PDB names from the HMM search results, limited by max_pdb . _template_alignment(self, cobalt_home) : Creates an alignment of template sequences, incorporating the isoform sequence. load_templates() : Initializes template objects based on PDB names and chain identifiers. _add_chain_breaks(self, sequences, model_cutoff) : Inserts chain breaks in alignments to facilitate sequence identity calculation. calculate_mutation_score(self, mappable_mutations) : Calculates a score based on the ratio of mappable mutations. calculate_structural_score(self, model_cutoff) : Assesses coverage of the isoform sequence by template structures. filter_templates_by_sequence_identity() : Filters out templates with sequence identity below a specified threshold. calculate_selection_score() : Computes a selection score based on structural and mutation scores. run_modeller(self, mutation, modeller_exec, model_cutoff) : Manages the execution of Modeller for structural modeling.","title":"Methods"},{"location":"modeller_manager/","text":"Modeller Manager Overview The ModellerManager class is designed to facilitate the process of protein modeling by interfacing with the Modeller software. This class is responsible for setting up and running Modeller scripts, handling mutations, and organizing input and output files. It provides a convenient way to perform protein structure predictions and mutations in a structured and automated manner. Class Initialization The constructor of the ModellerManager class takes several arguments: isoform : An object representing the isoform to be modeled. mutation : A list representing the mutation(s) to be applied to the isoform. modeller_exec : A string specifying the path to the Modeller executable. model_cutoff : An integer specifying the cutoff for model selection. Methods __enter__ and __exit__ These methods allow the ModellerManager class to be used within a context manager, ensuring that resources are managed efficiently. write This method prepares the necessary files for running Modeller. It applies mutations (if any) to the isoform sequence, writes the alignment file for Modeller, and generates the Modeller script. write_script Generates the python script to be executed by Modeller. This script specifies the alignment file, template structures, and the sequence to be modeled. It also sets up the modeling parameters and scoring methods. _mutate_reside A private method that applies the specified mutation to the isoform's aligned sequence. It returns a boolean indicating the success of the mutation. _add_chain_breaks This private method adds chain breaks to the sequences in cases where there is insufficient coverage for a specified number of residues. It is used to prepare the sequences for modeling. write_alignment Prepares the alignment file for Modeller, incorporating any mutations and chain breaks as necessary. This file is used by Modeller to understand the relationship between the template structures and the sequence to be modeled. run Executes the Modeller script, performing the actual modeling process. It handles the creation of the output directory and the execution of the script within the appropriate environment. load_log_file After Modeller has run, this method reads the log file generated by Modeller to extract the DOPE scores and other relevant metrics. This information is used for model selection and evaluation.","title":"Modeller manager"},{"location":"modeller_manager/#modeller-manager","text":"","title":"Modeller Manager"},{"location":"modeller_manager/#overview","text":"The ModellerManager class is designed to facilitate the process of protein modeling by interfacing with the Modeller software. This class is responsible for setting up and running Modeller scripts, handling mutations, and organizing input and output files. It provides a convenient way to perform protein structure predictions and mutations in a structured and automated manner.","title":"Overview"},{"location":"modeller_manager/#class-initialization","text":"The constructor of the ModellerManager class takes several arguments: isoform : An object representing the isoform to be modeled. mutation : A list representing the mutation(s) to be applied to the isoform. modeller_exec : A string specifying the path to the Modeller executable. model_cutoff : An integer specifying the cutoff for model selection.","title":"Class Initialization"},{"location":"modeller_manager/#methods","text":"","title":"Methods"},{"location":"modeller_manager/#__enter__-and-__exit__","text":"These methods allow the ModellerManager class to be used within a context manager, ensuring that resources are managed efficiently.","title":"__enter__ and __exit__"},{"location":"modeller_manager/#write","text":"This method prepares the necessary files for running Modeller. It applies mutations (if any) to the isoform sequence, writes the alignment file for Modeller, and generates the Modeller script.","title":"write"},{"location":"modeller_manager/#write_script","text":"Generates the python script to be executed by Modeller. This script specifies the alignment file, template structures, and the sequence to be modeled. It also sets up the modeling parameters and scoring methods.","title":"write_script"},{"location":"modeller_manager/#_mutate_reside","text":"A private method that applies the specified mutation to the isoform's aligned sequence. It returns a boolean indicating the success of the mutation.","title":"_mutate_reside"},{"location":"modeller_manager/#_add_chain_breaks","text":"This private method adds chain breaks to the sequences in cases where there is insufficient coverage for a specified number of residues. It is used to prepare the sequences for modeling.","title":"_add_chain_breaks"},{"location":"modeller_manager/#write_alignment","text":"Prepares the alignment file for Modeller, incorporating any mutations and chain breaks as necessary. This file is used by Modeller to understand the relationship between the template structures and the sequence to be modeled.","title":"write_alignment"},{"location":"modeller_manager/#run","text":"Executes the Modeller script, performing the actual modeling process. It handles the creation of the output directory and the execution of the script within the appropriate environment.","title":"run"},{"location":"modeller_manager/#load_log_file","text":"After Modeller has run, this method reads the log file generated by Modeller to extract the DOPE scores and other relevant metrics. This information is used for model selection and evaluation.","title":"load_log_file"},{"location":"pdb_manager/","text":"PDB Manager The PDBManager class is a tool designed for managing Protein Data Bank (PDB) files in Monviso. It leverages Biopython's capabilities to download, filter, and extract valuable information from PDB files. Features Download PDB Files : Download PDB files from the Protein Data Bank. Extract Clean Chain : Extracts a specific chain from a PDB file, filtering out non-standard residues and atoms, and checks for resolution cutoffs. Extract FASTA Sequence : Extracts the FASTA sequence from a PDB file. PDBManager Manages the downloading, cleaning, and processing of PDB files. Methods downloadPDB(pdb, out_path) : Downloads a PDB file and saves it locally. extract_clean_chain(input_pdb_path, output_pdb_path, chain_letter, resolution_cutoff) : Extracts a specific chain from a PDB file, ensuring it meets resolution quality standards. extract_fasta(pdb_name, pdb_path, output_fasta_path) : Extracts the FASTA sequence from a PDB file. Accessory class ChainSelection(Select) A subclass of Biopython's Select class for filtering specific chains and residues in a PDB file. Methods accept_model(model) : Accepts only the first model in a PDB file. accept_residue(residue) : Filters residues to include only standard amino acids. accept_chain(chain) : Filters for a specific chain. accept_atom(atom) : Filters for standard atoms.","title":"PDB manager"},{"location":"pdb_manager/#pdb-manager","text":"The PDBManager class is a tool designed for managing Protein Data Bank (PDB) files in Monviso. It leverages Biopython's capabilities to download, filter, and extract valuable information from PDB files.","title":"PDB Manager"},{"location":"pdb_manager/#features","text":"Download PDB Files : Download PDB files from the Protein Data Bank. Extract Clean Chain : Extracts a specific chain from a PDB file, filtering out non-standard residues and atoms, and checks for resolution cutoffs. Extract FASTA Sequence : Extracts the FASTA sequence from a PDB file.","title":"Features"},{"location":"pdb_manager/#pdbmanager","text":"Manages the downloading, cleaning, and processing of PDB files.","title":"PDBManager"},{"location":"pdb_manager/#methods","text":"downloadPDB(pdb, out_path) : Downloads a PDB file and saves it locally. extract_clean_chain(input_pdb_path, output_pdb_path, chain_letter, resolution_cutoff) : Extracts a specific chain from a PDB file, ensuring it meets resolution quality standards. extract_fasta(pdb_name, pdb_path, output_fasta_path) : Extracts the FASTA sequence from a PDB file.","title":"Methods"},{"location":"pdb_manager/#accessory-class","text":"","title":"Accessory class"},{"location":"pdb_manager/#chainselectionselect","text":"A subclass of Biopython's Select class for filtering specific chains and residues in a PDB file.","title":"ChainSelection(Select)"},{"location":"pdb_manager/#methods_1","text":"accept_model(model) : Accepts only the first model in a PDB file. accept_residue(residue) : Filters residues to include only standard amino acids. accept_chain(chain) : Filters for a specific chain. accept_atom(atom) : Filters for standard atoms.","title":"Methods"},{"location":"run/","text":"Run Class The Run class acts as the central coordinator within the MoNvIso software tool, orchestrating the sequence of operations necessary for the analysis and modeling of protein isoforms. This class manages the execution flow, starting from reading user inputs to the final step of modeling, ensuring that each process is executed in the correct order. Overview The Run class is designed to streamline the execution of various tasks including loading user inputs, creating Gene and Isoform objects, and managing the execution of their respective methods such as alignment, modeling, and reporting. It serves as a process manager, coordinating between user inputs, database parsing, and the execution of modeling algorithms. Class Methods __init__(self) Initializes a new instance of the Run class, setting up the necessary attributes for managing the execution flow. Attributes : args : A list to hold command line arguments. parameters : A list to store parameters from the parameters file. mutation_list : A list to maintain mutations parsed from the input file. input_parser : An instance of InputParser for parsing user inputs. genes : A list to hold Gene instances created based on the mutation list. load_input(self, argv) -> None Loads user input from the command line and parameters file, saving them as attributes of the class. Parameters : argv : Command line arguments. load_mutation_list(self) -> None Parses the list of mutations and genes from the mutation_list file and saves it as an attribute. create_genes(self) -> None Processes the mutation list to create Gene instances for each gene mentioned, storing them in the class's genes list. create_isoforms(self) -> None Loads isoforms for each gene from the Uniprot database, enriching the gene instances with isoform data. run_blastp(self) -> None Initiates a BLASTp search for every loaded isoform to find potential sequence alignments. run_cobalt(self) -> None Executes a COBALT run for sequence alignment of the loaded isoforms. run_hmmsearch(self) -> None Performs an HMM search for every loaded isoform, further refining the alignment process. load_templates(self) -> None Loads structural templates for the isoforms based on specified parameters. select_isoforms(self) -> None Selects isoforms for modeling based on weighted criteria, including structure, mutation impact, and sequence identity. start_modeller(self) -> None Runs the Modeller tool for the selected isoforms to generate structural models. write_report(self) Generates a comprehensive report detailing the outcomes of the modeling process for each gene.","title":"Run"},{"location":"run/#run-class","text":"The Run class acts as the central coordinator within the MoNvIso software tool, orchestrating the sequence of operations necessary for the analysis and modeling of protein isoforms. This class manages the execution flow, starting from reading user inputs to the final step of modeling, ensuring that each process is executed in the correct order.","title":"Run Class"},{"location":"run/#overview","text":"The Run class is designed to streamline the execution of various tasks including loading user inputs, creating Gene and Isoform objects, and managing the execution of their respective methods such as alignment, modeling, and reporting. It serves as a process manager, coordinating between user inputs, database parsing, and the execution of modeling algorithms.","title":"Overview"},{"location":"run/#class-methods","text":"","title":"Class Methods"},{"location":"run/#__init__self","text":"Initializes a new instance of the Run class, setting up the necessary attributes for managing the execution flow. Attributes : args : A list to hold command line arguments. parameters : A list to store parameters from the parameters file. mutation_list : A list to maintain mutations parsed from the input file. input_parser : An instance of InputParser for parsing user inputs. genes : A list to hold Gene instances created based on the mutation list.","title":"__init__(self)"},{"location":"run/#load_inputself-argv-none","text":"Loads user input from the command line and parameters file, saving them as attributes of the class. Parameters : argv : Command line arguments.","title":"load_input(self, argv) -&gt; None"},{"location":"run/#load_mutation_listself-none","text":"Parses the list of mutations and genes from the mutation_list file and saves it as an attribute.","title":"load_mutation_list(self) -&gt; None"},{"location":"run/#create_genesself-none","text":"Processes the mutation list to create Gene instances for each gene mentioned, storing them in the class's genes list.","title":"create_genes(self) -&gt; None"},{"location":"run/#create_isoformsself-none","text":"Loads isoforms for each gene from the Uniprot database, enriching the gene instances with isoform data.","title":"create_isoforms(self) -&gt; None"},{"location":"run/#run_blastpself-none","text":"Initiates a BLASTp search for every loaded isoform to find potential sequence alignments.","title":"run_blastp(self) -&gt; None"},{"location":"run/#run_cobaltself-none","text":"Executes a COBALT run for sequence alignment of the loaded isoforms.","title":"run_cobalt(self) -&gt; None"},{"location":"run/#run_hmmsearchself-none","text":"Performs an HMM search for every loaded isoform, further refining the alignment process.","title":"run_hmmsearch(self) -&gt; None"},{"location":"run/#load_templatesself-none","text":"Loads structural templates for the isoforms based on specified parameters.","title":"load_templates(self) -&gt; None"},{"location":"run/#select_isoformsself-none","text":"Selects isoforms for modeling based on weighted criteria, including structure, mutation impact, and sequence identity.","title":"select_isoforms(self) -&gt; None"},{"location":"run/#start_modellerself-none","text":"Runs the Modeller tool for the selected isoforms to generate structural models.","title":"start_modeller(self) -&gt; None"},{"location":"run/#write_reportself","text":"Generates a comprehensive report detailing the outcomes of the modeling process for each gene.","title":"write_report(self)"},{"location":"template/","text":"Template Class Overview The Template class is designed to manage protein templates in the context of Monviso workflow. It handles the selection, preparation, and analysis of protein database (PDB) files for modeling purposes. This includes downloading PDB files, cleaning them to focus on relevant chains, extracting sequences, via the PDB_manager class, and assessing template usability based on resolution and sequence identity. Methods __init__(self, pdb_name: str, out_path: Union[str, Path], gene_name: str, isoform_name: str, resolution_cutoff) Initializes a Template object with specified attributes including PDB name, output path, gene name, isoform name, and resolution cutoff. It prepares the environment for template handling, including directory setup and initial file management. get_pdb_file(self) Creates the directory for templates if it does not exist and downloads the PDB file if it's not already present. This method ensures that the required PDB files are available locally for further processing. get_clean_pdb_chain(self) Extracts the relevant chain from the PDB file, cleaning it to remove unnecessary atoms and saving it as a new file. This process is essential for focusing on the relevant part of the protein structure. get_fasta(self) Extracts the FASTA sequence from the cleaned PDB file of the chain of interest. This sequence is essential for further analyses, such as sequence alignment and homology modeling. add_aligned_sequence(self, aligned_sequence: str) Saves the aligned sequence as an attribute of the Template object. This method is typically called after sequence alignment has been performed, linking the alignment results back to the template. add_clean_aligned_sequence(self, clean_aligned_sequence: str) Similar to add_aligned_sequence , but for aligned sequences that include considerations for chain breaks or other structural nuances. calculate_sequence_identity(self, reference_sequence: str) Calculates the sequence identity between the template's sequence and a reference sequence. This metric is crucial for evaluating the suitability of a template for modeling based on how closely it matches the target sequence.","title":"Template"},{"location":"template/#template-class","text":"","title":"Template Class"},{"location":"template/#overview","text":"The Template class is designed to manage protein templates in the context of Monviso workflow. It handles the selection, preparation, and analysis of protein database (PDB) files for modeling purposes. This includes downloading PDB files, cleaning them to focus on relevant chains, extracting sequences, via the PDB_manager class, and assessing template usability based on resolution and sequence identity.","title":"Overview"},{"location":"template/#methods","text":"","title":"Methods"},{"location":"template/#__init__self-pdb_name-str-out_path-unionstr-path-gene_name-str-isoform_name-str-resolution_cutoff","text":"Initializes a Template object with specified attributes including PDB name, output path, gene name, isoform name, and resolution cutoff. It prepares the environment for template handling, including directory setup and initial file management.","title":"__init__(self, pdb_name: str, out_path: Union[str, Path], gene_name: str, isoform_name: str, resolution_cutoff)"},{"location":"template/#get_pdb_fileself","text":"Creates the directory for templates if it does not exist and downloads the PDB file if it's not already present. This method ensures that the required PDB files are available locally for further processing.","title":"get_pdb_file(self)"},{"location":"template/#get_clean_pdb_chainself","text":"Extracts the relevant chain from the PDB file, cleaning it to remove unnecessary atoms and saving it as a new file. This process is essential for focusing on the relevant part of the protein structure.","title":"get_clean_pdb_chain(self)"},{"location":"template/#get_fastaself","text":"Extracts the FASTA sequence from the cleaned PDB file of the chain of interest. This sequence is essential for further analyses, such as sequence alignment and homology modeling.","title":"get_fasta(self)"},{"location":"template/#add_aligned_sequenceself-aligned_sequence-str","text":"Saves the aligned sequence as an attribute of the Template object. This method is typically called after sequence alignment has been performed, linking the alignment results back to the template.","title":"add_aligned_sequence(self, aligned_sequence: str)"},{"location":"template/#add_clean_aligned_sequenceself-clean_aligned_sequence-str","text":"Similar to add_aligned_sequence , but for aligned sequences that include considerations for chain breaks or other structural nuances.","title":"add_clean_aligned_sequence(self, clean_aligned_sequence: str)"},{"location":"template/#calculate_sequence_identityself-reference_sequence-str","text":"Calculates the sequence identity between the template's sequence and a reference sequence. This metric is crucial for evaluating the suitability of a template for modeling based on how closely it matches the target sequence.","title":"calculate_sequence_identity(self, reference_sequence: str)"},{"location":"tutorial/","text":"Quick Start Tutorial for MonViso Reloaded This tutorial will walk you through the process of preparing input files and running MonViso Reloaded for mutation analysis. Step 1: Download the UniProt databases Download and decompress the following files: Database of isoforms Database of split variances Remember the directory containing the .fasta files. It will be one of the parameters required to run the software. Step 2: Prepare Input Files You will need to create two files: mutations.txt for listing the mutations and parameters.dat for specifying various parameters and paths used by MonViso Reloaded. Writing mutations.txt Create a text file named mutations.txt and fill it with your mutations of interest, formatted as shown below: GRIN1 R 844 C Ala 349 Thr Pro 578 Arg Ser 688 Tyr Tyr 647 Ser GRIN2B E413G C436R M1342R L1424F PRO1439ALA Each section starts with the gene name, followed by lines specifying the original amino acid, its position, and the mutated amino acid. Writing parameters.dat Create a text file named parameters.dat and specify the configuration for your analysis as follows: DB_LOCATION= [path to database location] COBALT_HOME=[path to cobalt binaries] HMMER_HOME=[path to HMMER binaries] MODELLER_EXEC=[command to run modeller e.g., mod10.5] RESOLUTION=4.50 SEQID=25 HMM_TO_IMPORT=100 MODEL_CUTOFF=5 PDB_TO_USE=10 NUM_OF_MOD_WT=1 NUM_OF_MOD_MUT=1 W_STRUCT=10 W_MUT=10 Step 3: Run the command monviso_reloaded -i mutations.txt -o out -p parameters.dat","title":"Quick start tutorial"},{"location":"tutorial/#quick-start-tutorial-for-monviso-reloaded","text":"This tutorial will walk you through the process of preparing input files and running MonViso Reloaded for mutation analysis.","title":"Quick Start Tutorial for MonViso Reloaded"},{"location":"tutorial/#step-1-download-the-uniprot-databases","text":"Download and decompress the following files: Database of isoforms Database of split variances Remember the directory containing the .fasta files. It will be one of the parameters required to run the software.","title":"Step 1: Download the UniProt databases"},{"location":"tutorial/#step-2-prepare-input-files","text":"You will need to create two files: mutations.txt for listing the mutations and parameters.dat for specifying various parameters and paths used by MonViso Reloaded.","title":"Step 2: Prepare Input Files"},{"location":"tutorial/#writing-mutationstxt","text":"Create a text file named mutations.txt and fill it with your mutations of interest, formatted as shown below: GRIN1 R 844 C Ala 349 Thr Pro 578 Arg Ser 688 Tyr Tyr 647 Ser GRIN2B E413G C436R M1342R L1424F PRO1439ALA Each section starts with the gene name, followed by lines specifying the original amino acid, its position, and the mutated amino acid.","title":"Writing mutations.txt"},{"location":"tutorial/#writing-parametersdat","text":"Create a text file named parameters.dat and specify the configuration for your analysis as follows: DB_LOCATION= [path to database location] COBALT_HOME=[path to cobalt binaries] HMMER_HOME=[path to HMMER binaries] MODELLER_EXEC=[command to run modeller e.g., mod10.5] RESOLUTION=4.50 SEQID=25 HMM_TO_IMPORT=100 MODEL_CUTOFF=5 PDB_TO_USE=10 NUM_OF_MOD_WT=1 NUM_OF_MOD_MUT=1 W_STRUCT=10 W_MUT=10","title":"Writing parameters.dat"},{"location":"tutorial/#step-3-run-the-command","text":"monviso_reloaded -i mutations.txt -o out -p parameters.dat","title":"Step 3:   Run the command"},{"location":"workflow/","text":"Workflow For the user The user provides the parameters (software paths, model settings, ...) The user provides a list of genes and mutations MoNvIso searches UniProt's databases for the canonical sequence and other isoforms In the output path, a directory is created for every gene In every gene's directory, a sub-directory is created for every isoform The PDB databank is queried for every sequence and returns a list of similar sequences HMMER is used to combine the results and start a new search for templates The PDB files of the templates are downloaded, and the template chain is extracted The sequence of the extracted chains is aligned with the sequence to model Chain breaks are introduced in place of large gaps The number of mutations that are mappable and the value of sequence identity are measured Isoforms are ranked based on their score (ability to model the mutated protein) The aligned sequence is passed to Modeller for modelling Under the hood The MoNvIso run is coordinated by an instance of the Run class. The Run.load_mutation_list() method passes the mutation file to the Input parser, which returns the mutations in a list type The Run.load_input() method takes the input parameters and passes them to the Input_parser file, which returns them processed as a dictionary The Run.create_genes() method instances the Gene object, one object per gene to model. These genes are stored in a list as a local attribute of the Run. The Run.create_isoform() method loads the UniProt databases via a Database_Parser object. The database returns one sequence per isoform per gene. Each is used to instance an Isoform object. Every isoform object is stored in a list as an attribute of the corresponding gene. At this point, the Gene object and Isoform objects take care of creating their corresponding directories and .fasta files with the alignments The Run object coordinates the creation of alignments with the Run.run_blastp() , Run.run_cobalt() , Run.run_hmmsearch() methods. Each isoform of each gene runs a blastp search, saves the output, creates a .hmm with HMMER, and uses it for a search with hmmsearch. The output contains the PDB IDs and chains of the best templates Run.load_templates() : For every proposed template, a Template instance is created, which takes care of downloading and extracting the chain and fasta sequence from the PDB file. The operations on the PDB file are managed by the PDB_manager class. All the sequences of the templates are aligned with Cobalt. Run.select_isoform() : For every isoform, the mutation score (How many mutations can be mapped on the sequence), structural score (sequence identity), and the Selection score (the first two combined) are calculated. The isoforms are ranked, and the ones with higher scores are preferred to model the mutation. Run.start_modeller() : The isoforms that can be modeled will create the Modeller input file and start a Modeller run.","title":"Understanding the Workflow"},{"location":"workflow/#workflow","text":"","title":"Workflow"},{"location":"workflow/#for-the-user","text":"The user provides the parameters (software paths, model settings, ...) The user provides a list of genes and mutations MoNvIso searches UniProt's databases for the canonical sequence and other isoforms In the output path, a directory is created for every gene In every gene's directory, a sub-directory is created for every isoform The PDB databank is queried for every sequence and returns a list of similar sequences HMMER is used to combine the results and start a new search for templates The PDB files of the templates are downloaded, and the template chain is extracted The sequence of the extracted chains is aligned with the sequence to model Chain breaks are introduced in place of large gaps The number of mutations that are mappable and the value of sequence identity are measured Isoforms are ranked based on their score (ability to model the mutated protein) The aligned sequence is passed to Modeller for modelling","title":"For the user"},{"location":"workflow/#under-the-hood","text":"The MoNvIso run is coordinated by an instance of the Run class. The Run.load_mutation_list() method passes the mutation file to the Input parser, which returns the mutations in a list type The Run.load_input() method takes the input parameters and passes them to the Input_parser file, which returns them processed as a dictionary The Run.create_genes() method instances the Gene object, one object per gene to model. These genes are stored in a list as a local attribute of the Run. The Run.create_isoform() method loads the UniProt databases via a Database_Parser object. The database returns one sequence per isoform per gene. Each is used to instance an Isoform object. Every isoform object is stored in a list as an attribute of the corresponding gene. At this point, the Gene object and Isoform objects take care of creating their corresponding directories and .fasta files with the alignments The Run object coordinates the creation of alignments with the Run.run_blastp() , Run.run_cobalt() , Run.run_hmmsearch() methods. Each isoform of each gene runs a blastp search, saves the output, creates a .hmm with HMMER, and uses it for a search with hmmsearch. The output contains the PDB IDs and chains of the best templates Run.load_templates() : For every proposed template, a Template instance is created, which takes care of downloading and extracting the chain and fasta sequence from the PDB file. The operations on the PDB file are managed by the PDB_manager class. All the sequences of the templates are aligned with Cobalt. Run.select_isoform() : For every isoform, the mutation score (How many mutations can be mapped on the sequence), structural score (sequence identity), and the Selection score (the first two combined) are calculated. The isoforms are ranked, and the ones with higher scores are preferred to model the mutation. Run.start_modeller() : The isoforms that can be modeled will create the Modeller input file and start a Modeller run.","title":"Under the hood"}]}